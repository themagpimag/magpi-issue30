Object-orientated languages such as Java, Python and C++ all allow inheritance structures.  The idea of inheritance is that several classes may have a basic set of member functions or data members that are common between them.  Rather than implement these members functions or data members several times, they can instead be implemented in a base class.  The other classes then inherit from the base class, to include the member functions or data members.

Inheritance structures can include a large number of classes.  As the number of classes involved becomes larger, the compilation time will increase and the effects of changing the base class design will be more dramatic.  Therefore, inheritance should be used carefully, where the base class design should be as robust as possible.  Unlike Java, C++ allows a derived class to inherit from several base classes.  However, this feature should be used sparingly, to avoid software from becoming too complicated for other developers to understand.

The syntax and usage of C++ classes is discussed in Issues 23, 24 and 27 of The MagPi.  This article builds on concepts introduced in these previous articles.  This tutorial assumes that g++ and make have been installed.  Using the latest Raspbian image, these can be installed by typing:

 sudo apt-get install -y g++ make

 
Three layer inheritance

Open a text editor such as nano or emacs and create a file called Bag.h.  Then add the C++ code on the top of the next page and save the file.  This is the base class declaration and implementation.  Since the functionality of the member functions is very simplistic, it has been implemented within the header file.  The class contains one data member that holds the volume of the bag.  There is a constructor that has a default value.  This implies that the constructor can be used with a value or without a value.  The two member functions return and set the data member value.  The data member is declared as private.  This implies that it will not be directly accessible in the derived class.  To allow direct access to the data member in the derived class, the data member should be declared as protected or public.
 

Now that a class has been written, another class can inherit from it.  Create another file called ColouredBag.h and add the C++ code given below.
The ColouredBag class is a simple container class that inherits from the Bag class.  This implies that it has one data member within the class declaration and one data member by inheritance.  The ColouredBag constructor calls the Bag constructor and sets the value of the data member.  There are two accessor functions in the ColouredBag class and two more that are inherited from the Bag class.

Inheritance structures can include several layers of classes.  To demonstrate this, create another file called BeanBag.h that contains the C++ code given below:
 
The BeanBag class inherits from the ColouredBag class, which in turn inherits from the Bag class.  This implies that the BeanBag class includes functions and data members that are present in both base classes.  Now create another file called main.cpp and add the C++ code given below.  Then compile the main.cpp file using g++ or a Makefile as demonstrated in the previous C++ articles.  Then run the program to print the values on the screen. 

Polymorphism and interfaces

Polymorphism can be used to define interface classes.  An interface class is an abstract base class that contains purely virtual functions and a virtual destructor.  Purely virtual functions are not implemented within the declaration of the base class.  Therefore, when a derived class inherits from the interface class it has to implement the purely virtual functions otherwise it will not compile.  Having defined an interface class, an interface pointer can be used to access many different implementations of the interface.  This implies that large sections of a program can rely on the presence of the member functions defined in the interface class, without needing to know which implementation of the interface is actually being used.  To demonstrate this principle, create a file called IVectorTransform.h and add the C++ code given below:
This interface class contains two purely virtual member functions, to transform a two-dimensional vector and return the transform as a string.  The TwoVector class is given in Issue 27 of The MagPi, where both the TwoVector.h and TwoVector.cpp files are needed.  Next, create a file called MatrixTransform.h that contains:

The MatrixTransform class includes the declaration of the transform and str member functions without the =0.  This implies that these functions are virtual, but not purely virtual.  Therefore, they are implemented for this class.  The class also contains a constructor to set the matrix normalisation and initialise the values used for each of the matrix elements.  Create another file called MatrixTransform.cpp and add:
The transform function performs matrix multiplication between the two-dimensional vector and the 2x2 matrix.  The results from this multiplication are then used to create a new TwoVector instance, which is returned by the function.  The str function uses a string stream instance to return a string representation of the matrix and its normalisation.  To complete the example program, create another file called main.cpp and append:
Then, similar to the article in Issue 27, use a Makefile to compile the .cpp files together to make an executable.  When the program is run it will print the values of the two-dimensional vector components before and after the matrix transformation.  Notice that the pointer type used to refer to the MatrixTransform object is an IVectorTransform pointer.  While the pointer type is the base class, the derived class member functions are called.  If the base class member functions were not virtual, then the base class member functions would have been called instead.
