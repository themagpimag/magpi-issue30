<!DOCTYPE html><html><head><title>Enriching an NMEA Stream</title> <link rel="stylesheet" href="../stylesheet.css" type="text/css"/><script type="text/javascript">var showParserSection=false;var showSOPSection=false;var showTWSection=false;var showTWCalcSection=false;var displayParserSection=function(){showParserSection=!showParserSection;document.getElementById('whatsaparser').style.display=(showParserSection?'inline':'none');};var displaySOPSection=function(){showSOPSection=!showSOPSection;document.getElementById('whatsasop').style.display=(showSOPSection?'inline':'none');};var displayTWSection=function(){showTWSection=!showTWSection;document.getElementById('true-wind').style.display=(showTWSection?'inline':'none');};var displayTWCalcSection=function(){showTWCalcSection=!showTWCalcSection;document.getElementById('true-wind-calc').style.display=(showTWCalcSection?'inline':'none');};</script> </head><body><a href="../readme.html"><< Raspberry Coffee page</a><h1>Enriching the on-board NMEA Stream with a Raspberry PI and Java</h1><hr><p><p><ul><li><a href="#01">The Context</a></li> <li><a href="#02">Introducing the Raspberry PI</a></li> <li><a href="#02-1">Extra data</a></li> <li><a href="#02-2">Summary</a></li> <li><a href="#03">Resources</a></li> <li><a href="#04">Some last comments</a></li></ul><hr></p>Most - if not all - the software and hardware components mentioned in this document are reachable from the <a href="#04">Resources</a> section, at the end of this document.<hr><p><table width="98%"><tr><td><h2><a name="01">The context</a></h2></td><td align="right"><a href="#"><small>Top</small></a></td></tr></table>Several electronic instruments are available on boats (sailing boats, motor boats).<br>Those instruments read, compute, and eventually provide various data used for navigation. The idea here is to have an easy access to those data, display them on several kinds of devices (and not only on the expensive displays sold by the nautical electronic providers), and possibly add more data to the ones already managed and manipulated by your existing electronic instruments.<h3>NMEA</h3>The electronic instruments available on boats are used to measure data like the boat speed and heading, the wind speed and direction, read the boat position (GPS), all this kind of things used for navigation.<br>Some data are read from transducers (boat speed through water, wind speed, compass heading, etc), and some are computed (true wind speed and direction, true heading, etc).<br>Those data are usually available in the NMEA format. NMEA stands for <b>N</b>ational <b>M</b>arine <b>E</b>lectronics <b>A</b>ssociation. The definition of the NMEA strings is one of the oldest electronic standards.<br>The NMEA sentences (or strings) are human readable (i.e. it is a text format, it can be some times a bit cryptic). They can be easily parsed by a computer program, several such parsers can be found for free.<br>Here is what an NMEA stream can look like:<div style="padding:5px; background:#ddd; border-radius:5px; overflow-x: scroll; overflow-y: scroll;border:1px solid #CCC; margin-top:10px; height: 200px; width: 600px; resize:both;"><pre style="text-align: left; font-family:'Source Code Pro', 'Courier New'; font-size:11px; color:white; background-color:#1e1e1e;">
$IIMWV,112,R,00.8,N,A*19
$IIMWV,109,T,00.7,N,A*1A
$IIMTA,31.5,C*02
$IIRMB,A,0.23,R,,HMB-3   ,,,,,001.20,184,,V,A*1F
$IIXDR,P,1.0156,B,0*71
$WIMDA,29.991,I,1.016,B,31.5,C,,,,,,,,,,,,,,*3B
$IIRMC,225158,A,3730.075,N,12228.854,W,,,021014,15,E,A*3C
$IIVHW,,,355,M,00.0,N,,*67
$IIVLW,08200,N,000.0,N*59
$IIVWR,112,R,00.8,N,,,,*6B
$IIGLL,3730.075,N,12228.854,W,225158,A,A*4C
$IIHDG,356,,,15,E*16
$IIMTW,+16.0,C*3F
$IIMWV,111,R,00.9,N,A*1B
$IIMWV,112,T,00.8,N,A*1F
$IIRMC,225158,A,3730.076,N,12228.855,W,,,021014,15,E,A*3E
$IIVHW,,,356,M,00.0,N,,*64
$IIVLW,08200,N,000.0,N*59
$IIVWR,111,R,00.9,N,,,,*69
$IIGLL,3730.076,N,12228.855,W,225158,A,A*4E
$IIHDG,356,,,15,E*16
$IIMTW,+16.0,C*3F
...
          </pre></div><div onclick="displayParserSection();" title="Click here for details" style="padding: 5px; background:#ffffcc; border-radius:5px; border:1px solid #CCC; margin-top:10px; margin-left: 10px; margin-right: 10px;"><dl><dt><h5>&nbsp;Hint: What is a parser?</h5></dt><dd><div id="whatsaparser" style="display: none;">A parser is this piece of software that turns some text into some "object", or actually some "structure".<br>An "object" is a programmatic structured entity - belonging to a specific program, written in a specific language.<br>Let us take an example.<br>Let us take the <code>RMC</code> NMEA string, present in the stream featured above.<br>Its meaning is <code><b>recommended minimum data for gps</b></code>. (I know: where does the <b>C</b> come from?).<br>Here is its structure, as described in the NMEA specification:<pre style="width: 90%;">

                  1      2 3        4 5         6 7     8     9      10    11
           <font style="background-color: yellow;">$GPRMC,123519,A,4807.038,N,01131.000,E,022.4,084.4,230394,003.1,W*6A</font>
                  |      | |        | |         | |     |     |      |     |
                  |      | |        | |         | |     |     |      |     Variation sign
                  |      | |        | |         | |     |     |      Variation value
                  |      | |        | |         | |     |     Date DDMMYY
                  |      | |        | |         | |     COG
                  |      | |        | |         | SOG
                  |      | |        | |         Longitude Sign
                  |      | |        | Longitude Value
                  |      | |        Latitude Sign
                  |      | Latitude value
                  |      Active or Void
                  UTC
                </pre>This is a good illustration of what an NMEA string can be.<ul><li>It begins with the character <code>$</code></li> <li>Between the <code>$</code> and the first comma, are 5 letters<ul><li type="disc">2 characters for the device identifier (<code>GP</code> in this case)</li> <li type="disc">3 characters for the sentence identifier (<code>RMC</code> in this case)</li></ul></li><li>The 3 last characters are a checksum, used to confirm that the sentence is valid (<code>*6A</code> in this case)</li> <li>Between the first comma and the checksum is the string to parse, as described above</li></ul>A json (<b>J</b>ava<b>S</b>cript <b>O</b>bject <b>N</b>otation) parser could turn that string into a json object like this:<pre style="width: 90%;">

      {
        type: 'RMC',
        active: true,
        cog: 84.4,
        sog: 22.4,
        declination: -3.1,
        date: 764426119000,
        pos: {
          latitude: 48.1173,
          longitude: 11.516666666666667
        }
      }
                </pre>The object and the string are semantically 100% equivalent (that also means that the string can be fully re-generated from the object).<br>Such an object can then be used in a program (a JavaScript one in this case, obviously). Depending on the language you use, you need a parser written in it. <br><i>For information, <b>Java</b> and <b>JavaScript</b> are two totally different languages, as close to each other as <b>Ham</b> is close to <b>Hamburger</b>.</i><br>In the object above:<ul><li><code>cog</code> is the <b>C</b>ourse <b>O</b>ver <b>G</b>round, in degrees</li> <li><code>sog</code> is the <b>S</b>peed <b>O</b>ver <b>G</b>round, in knots</li> <li><code>date</code> is an <a href="http://dictionary.reference.com/browse/epoch" target="dico">epoch</a> (for computers, it is the number of milliseconds since January 1st 1970 at 00:00:00.000. All computers and languages know how to deal with that).<br>Here, <code>764426119000</code> is equivalent to <code>Wed Mar 23 1994 12:35:19 UTC</code>.<br>Dates and times management is a very vast topic. See <a href="http://hocus-blogus.blogspot.com/2012/06/time-and-date-management-in-java.html" target="HB">this article</a>. </li></ul>In short, this is what an NMEA parser would be doing. See the <a href="#04">Resources</a> section for details about the Java parser used here.</div></dd></dl></div><h3>Several challenges</h3><ul><li><h4>Serial Port access</h4>Many navigation stations deliver the NMEA data through a Serial interface, which is compatible with many devices (like laptop computers).<br>The unfortunate thing about the serial ports is that they are to be accessed exclusively. That means that when one program - running on a laptop for example - is reading the data emitted by the NMEA station, those data are <b>not</b> available for any other program until the serial connection is released by the program using it.<br>This can be painful when you want to simultaneously<ul><li type="disc">Read the GPS data from a chart plotter (like OpenCPN)</li> <li type="disc">Read the NMEA stream to display the data in a graphical interface</li> <li type="disc">Read the GPS data from Airmail, to use a propagation chart to aim for the most appropriate SSB land-station</li> <li type="disc">etc...</li></ul></li><li><h4>Introducing other data, other sensors</h4>In some cases, you could be interested in monitoring data that are not managed by an NMEA station (like the batteries voltage).<br>You could also be interested in monitoring data managed by NMEA, but not by your NMEA station (like air temperature, atmospheric pressure).<br>Injecting those data in the NMEA Stream you read from your station would<ul><li type="disc">Make them available for all the NMEA-aware programs reading the NMEA stream</li> <li type="disc">Allow you to log them to monitor, display, or replay them</li></ul><i>Note:</i> You might be interested some computed data that are not returned by your NMEA station (like True Wind speed, direction, angle for example). They could be computed from existing data, and injected in the stream just like above. </li><li><h4>Power consumption</h4>A laptop can sound like an obvious solution for your on-board computing needs, but the power consumption of a laptop is not always negligible. The NMEA stations usually draw a very small amount of current, but a laptop power adaptor can draw between 1 and 3 Amps, which is a lot when you have limited energy available, like on a sail boat for example. </li><li><h4>Other devices</h4>The computer you would use to read the NMEA stream will probably sit close to the chart table, but you might very well be interested in visualizing the data it computes on deck, from existing displays, or from some wireless devices, like tablets or smart-phones. </li></ul></p><p><table width="98%"><tr><td><h2><a name="02"><h2>Introducing the Raspberry PI</h2></a></h2></td><td align="right"><a href="#"><small>Top</small></a></td></tr></table>The Raspberry PI is a credit-card-size computer that can be used to address <b>all</b> the challenges mentioned above.<br>It is a <b>fully featured Linux computer</b>, that you can get for less than $40 (2014).<br>Linux has no incompatibility with Java, hence Java runs just fine on the Raspberry PI.<br>The choice of a language is a delicate topic; it has some close-to-religious dimension... You cannot convince someone who does not believe you that <b>your</b> language is better than <b>his</b> language. At least, I can't.<br>I will spend no time trying to convince anyone to use Java rather than any other language.<br>But I use Java at least because<ul><li>I know it (and I like it)</li> <li>It is free and Open Source</li> <li>There is a huge Java community (9 million people in 2014), no question will remain un-answered</li> <li>It is very scalable (runs on <small>very</small> small and <big>very</big> big machines)</li> <li>Once it runs, it runs <i>the same</i> on all systems (Windows, Mac, Linux, etc)</li> <li>It has gorgeous debugging (local and remote) capabilities</li> <li>A jar file (<b>J</b>ava <b>AR</b>chive) that runs somewhere will run the same anywhere Java runs, no re-compilation is required</li> <li>Many good IDEs (<b>I</b>ntegrated <b>D</b>evelopment <b>E</b>nvironment</b>) are available for free</li></ul>This being said, all the softwares I wrote to run on the Raspberry PI (in this document) are written in Java. They are all in Open Source.<h3>Navigation Console</h3>The Navigation Console is a program I've been using on board for several years (I wrote it, partly at sea). It provides - among other features - a graphical user interface to the navigation data.<br><p style="text-align: center;"><a href="img/console.jpg" target="img"><img src="img/console.jpg" title="Click to enlarge" width="701" height="414"></a><br><i>The Navigation Console, Swing GUI</i></p><br>I have recently enhanced it to run in headless mode (i.e. without graphical user interface), to run on the Raspberry PI. And it works just fine. In those headless conditions, the role of the console is to read and compute the data, possibly log, and re-broadcast them on one or more channels. For such a re-broadcasting to happen, the Raspberry PI creates its own ad-hoc wireless network. Other devices will join this network, and will then have access to the re-broadcasted data.<p style="text-align: center;"><a href="img/IMAG0685.jpg" target="img" name="RPi"><img src="img/IMAG0685.jpg" title="Click to enlarge" width="701" height="395"></a><br><i>The Raspberry PI at work on board, in the chart table.</i></p>Notice on the picture above: the slice of Pi on top of the Raspberry PI, hosting the battery monitoring device, and the small breadboard, with a BMP180 PCB plugged in it, and connected to the Slice of Pi. We'll talk more about those two later in this document.<div onclick="displaySOPSection();" title="Click here for details" style="padding: 5px; background:#ffffcc; border-radius:5px; border:1px solid #CCC; margin-top:10px; margin-left: 10px; margin-right: 10px;"><dl><dt><h5>&nbsp;Hint: What is a slice of PI?</h5></dt><dd><div id="whatsasop" style="display: none;">No pastry..., it is a PCB (Printed Circuit Board), designed to fit on top of the Raspberry PI.<br>Just <a href="http://www.lmgtfy.com/?q=%22Slice+of+Pi%22+%2B+%22Raspberry+PI%22" target="lmgfy">google it</a>.</div></dd></dl></div><br>We need to plug-in three USB sockets here:<ul><li>One for the wireless network dongle</li> <li>One for a small wireless keyboard</li> <li>And most important, one for the NMEA input</li></ul>The device featured here is a Raspberry PI Model B, that comes with two USB ports. The more recent one B+ has 4 USB ports; this would cancel the need for the USB hub you can see on the picture, as we would have by default have more than the three USB sockets we need in this context.<h4>Re-broadcasting</h4>Many navigation programs provide the possibility to read the NMEA streams from other channels than the Serial connection. Those other protocols are usually TCP (<b>T</b>ransfer <b>C</b>ontrol <b>P</b>rotocol) or UDP (<b>U</b>ser <b>D</b>efined <b>P</b>rotocol). Also available for the same purpose: HTTP (<b>H</b>yper <b>T</b>ext <b>T</b>ransfer <b>P</b>rotocol), RMI (<b>R</b>emote <b>M</b>ethod <b>I</b>nvocation), WebSocket...<br>The idea here is to use a Serial port of the Raspberry PI (USB) to read the NMEA data from the station, and <i>then</i> to re-broadcast the data <i>as they were read</i> on another channel. All the channels mentioned above can be consumed simultaneously from several clients. This way, the data read by the Raspberry PI are simultaneously available to all the devices interested in reading them.<br>The Navigation Console provides TCP, UDP, HTTP, and RMI servers. Those servers are very tiny, and do not overload the Raspberry PI.<br>The HTML5 WebSocket protocol is also available, through node.js and a user-exit.<h4><a name="multiplexing">Multiplexing</a></h4>Multiplexing is this technique that takes data from several several origins and merges them into a single channel.<br>Here we read NMEA data from the NMEA station (already NMEA formatted, obviously), and the program puts them in a cache (technically, it is a HashMap, living in a singleton). Whatever component - like other components of the soft that would need the GPS position, all the different servers (TCP, UDP, etc) would read that cache as the single point of truth. Computed data are also read from the cache. As a matter of fact, all computed data (like True Wind Direction and Speed, Current Speed and Direction, Performance, etc) are re-calculated <i>every time</i> a new value is inserted into the cache by the NMEA reader.<br><b>Two things to notice</b>:<ul><li>The HashMap is a Java <i>dynamic</i> structure</li> <li>The cache also uses a Publish/Subscribe architecture that implements a listener pattern</li></ul>We will use those aspects to inject extra data in the cache.<br>For example, you can read the battery voltage from some specific device you can build (<a href="http://www.lediouris.net/RaspberryPI/ADC/monitor-12v.html" target="OS">Open Source</a> as well), turn this value into an NMEA Sentence, and inject it in the cache. Whatever component has subscribed to the <code>manageEvent</code> event in its listener will be notified of the injection of the NMEA sentence.<br>The same is true for any other data. I used a BMP180 PCB (from <a href="http://adafruit.com" target="adafruit">Adafruit</a>) to get the air temperature and the atmospheric pressure (NB: unlike the battery voltage, those data <i>do</i> have an NMEA equivalent, but not available on the NMEA station I have on board). They are read from the sensors, turned into an NMEA string, and injected in the cache. See in the picture below the data prefixed with BAT (custom NMEA chain, BATtery), MTA (Air Temperature), MMB (Barometric Pressure). The Character Console featured below is reading the data from the cache they're injected in.<h4>Character Console</h4><p style="text-align: center;"><a href="img/IMAG0686.jpg" target="img"><img src="img/IMAG0686.jpg" title="Click to enlarge" width="701" height="395"></a><br><i>The Character Console, on a 7" RCA screen, on board.</i></p>This one provides for (almost) nothing an access to the data computed by the Raspberry PI. It can be customized by the user. The goal here is to have an access to those data, without having to turn on a laptop or any such demanding device. The only one to switch on is the screen itself, which can be turned back off when done reading.<h4>Other devices</h4><h5>TCP and friends</h5><p style="text-align: center;"><a href="img/IMAG0687.jpg" target="img"><img src="img/IMAG0687.jpg" title="Click to enlarge" width="701" height="395"></a><br><i>On the laptop, using TCP to get the data from the Raspberry PI, <u>simultaneously</u> using the Graphical Console, and OpenCPN.</i></p>TCP and UDP are light protocols, designed for computer-to-computer communication. They are both based on a socket mechanism. Once a socket is established between two computers (a client, and a server), then the logic of the dialog will be implemented by the programs running on both client(s) and server, which they have to agree on (to understand each other). In our case, this is extremely simple, once a client is connected, the server is sending it all the valid NMEA strings it reads.<h5>HTTP</h5>HTTP has always been HTML's best friend. HTML is a markup language (widely used to design web pages), HTTP is a transport protocol that can convey HTML streams.<br>HTTP is based on TCP, but is has been <i>designed</i> to be a request-response protocol. For the server to do something, a client has to ask first.<br>As long as you have a browser on the device you want to use, then HTTP would be an obvious choice. To refresh the data, we would use AJAX, in order to avoid a refresh to be performed by the client.<br>HTML5 provides elaborated graphic capabilities that will give us the possibility to come up with a nice graphical user interface.<p style="text-align: center;"><a href="img/day.console.jpg" target="img"><img src="img/day.console.jpg" title="Click to enlarge" width="701" height="283"></a><br><i>The HTML5 console, as seen in a browser (laptop, tablet, smart-phone, ...)</i></p>The HTML console is refreshed every seconds.<h5>WebSocket</h5>The WebSocket protocol has been introduced with the release of HTML5.<br>It is also based on TCP.<br>One of the drawbacks of HTTP is that it is a request-response (a.k.a. push-pull) protocol. You <b>have</b> to make a request to get a response. For example, if you want to get a flight status from some airline website, the first time you reach the page, it gives you the expected arrival time of the flight. Every time you want to see it this estimated time has changed, you <b>must</b> refresh your page. In other words, request it again.<br>The WebSocket protocol precisely addresses (among others) this kind of issue. Once the client (i.e. your browser) is connected on the server, data will be pushed (by the server, to the client) <b>as needed</b>, without requiring the client to refresh its page. This clearly divides the traffic by two.<br><i>The browser you use must be WebSocket aware though. As of now (2015), some browsers (like Internet Explorer 9) still do not support it.</i><br><br>In the Navigation Console, the WebSocket interface is implemented as a user-exit.<br>It requires a WebSocket server to be available. We can (fortunately) run it on the Raspberry PI. Node.js is the one we use, with its WebSocket module. <a href="http://bit.ly/101WJUZ" target="Google">Google it</a> to see how to install all this, it is fast and easy.<br>In short, here is how it is going:<ol><li>An HTTP/WebSocket server is started on the Raspberry PI</li> <li>A user-exit (listening to the cache) is pinging the WebSocket server everytime some data is inserted</li> <li>A web page (WebSocket client) will reach the WebSocket server to display real-time data, pushed by the server, from as many clients as needed</li></ol>The WebSocket console looks exactly like the HTML5 one featured above. But it takes about half the resources. And the data are refreshed <i>by the server</i>.</p><h4>Summary of the architecture</h4><p style="text-align: center;"><a href="img/setup.jpg" target="img"><img src="img/setup.jpg" title="Click to enlarge" width="701" height="523"></a><br><i>The full set. The Raspberry PI is the heart of the system.<br>HTTP and WebSocket play the same role on the picture.</i></p><p>The Raspberry PI is the <i>only</i> device connected to the NMEA Interface (the boat's instruments). It is the first to be turned on, and the last to be switched off. I've been running it continuously for weeks, without any glitch.<br><dl>The Raspberry PI fulfils two distinct functions:<ul><li>It enriches the NMEA Stream read from the NMEA Station, by computing new data, and adding data read from the sensors it is connected to</li> <li>The enriched stream is then re-broadcasted using non-exclusive protocols, so it can be read and used <i>simultaneously</i> by a variety of devices, on its own network.</li></ul></dl><br>The Raspberry PI rebroadcasts the data using TCP, HTTP, and WebSocket (in this case). Data can also be logged on the Raspberry PI's SD card.<br>The laptop uses TCP to consume the data, and can run simultaneously several programs using the NMEA data.<br>The character console also runs on the Raspberry PI, but in another process than the one reading the data. This way, the character console can be stopped, without interrupting the logging and re-broadcasting performed by the NMEA Reader process.<br>Tablets and smart-phones can join the wireless network, using HTTP or WebSocket to display the HTML5 Console.</p>See on the picture above the central place taken by the Raspberry PI. It is acting as the main hub of all the system. It is the only one reading the NMEA data out of the NMEA station. In addition, it manages its own sensors to read extra data (in this case: battery voltage, atmospheric pressure and air temperature). All the data gathered by the Raspberry PI are re-broadcasted onto several channels, depending on the devices connected on the Raspberry PI's own ad-hoc wireless network. Those devices can join or leave the network at their leisure, the only piece remaining alive will be the Raspberry PI, maintaining all the infrastructure. And all this for between 0.13 and 0.19 Amps. The character console running on the 7" RCA screen preserves a rapid access to the data currently available on the Raspberry PI.<p><table width="98%"><tr><td><h2><a name="02-1"><h2>Extra data</h2></a></h2></td><td align="right"><a href="#"><small>Top</small></a></td></tr></table>What we've seen so far does not involve the extra data we can feed in the NMEA stream from the Raspberry and its connected sensors.<br>We've seen <a href="#RPi">above</a> that the Raspberry PI has 2 extra sensors to<ul><li>Monitor the voltage of the batteries</li> <li>Read the atmospheric pressure and the air temperature</li></ul>The data read from those sensors are converted into an NMEA string, and injected into the NMEA stream (see the <a href="#multiplexing">multiplexing</a> section for details).<br>As they're part of the NMEA stream, any client reading those data <i>cannot</i> tell their origin.<br>For the same reason, those data can be logged along with all the others.<dl><dt>About logging...</dt><dd>The disk of the Raspberry PI is actually an SD card. I use a 16GB SD Card. It allows me <b><i>several weeks</i></b> of continuous logging.</dd></dl><br>Let us take the battery voltage data as an example.<br>Here is a graphical rendering of a several day logging of the battery voltage.<p style="text-align: center;"><a href="img/voltage.jpg" target="img"><img src="img/voltage.jpg" title="Click to enlarge" width="701" height="128"></a><br><i>Battery Voltage logging</i></p>Using <a href="https://code.google.com/p/javanauticalalmanac/" target="JNA">another Java project</a> I own, I can calculate the sunrise and sunset, at the location of the boat, for the date of the logging. This is what's rendered in the background of the graph, gray for the night, white for the day.<h3>A quick analysis</h3>The small notches on the red line correspond to the periods when the fridge goes on.<br>During the day (white background), you can notice that the voltage goes up, and back down before dark. This is because of the solar panel, that feeds the batteries.<br><i>Orienting the solar panel so it permanently faces the sun makes a very big difference!</i> Specially on this graph, during the first part of the day.<br>During the night (gray background), there is nothing to charge the batteries.<br>The notches corresponding to the fridge are there, but beside that, it is clear that the average voltage does not drop during the night.<br><b>This means that there is no leak in the circuit.</b> And <i>that</i> is good news!<h3>More data</h3>We can also log the atmospheric pressure, read from the BMP180 sensor. That one can prove very useful to anticipate atmospheric phenomenons. Logging those values and sending a warning when the pressure drops below a given threshold becomes very easy, and can happen to be a precious asset.<br><br>There are <i>many</i> cheap sensors that can be used with the Raspberry PI. Many of the data they emit can certainly contribute to a safer and more accurate navigation.<br>The only boundary is your imagination!<br><br>It is also possible to compute NMEA data that would not be returned by your NMEA Station. Data about True Wind for example, like its speed, angle and direction. Those data are to be calculated, and turned into valid NMEA strings such as <code>VWT</code>, <code>MWD</code> and <code>MWV</code>.<br>Any program, aware of those sentences, can render them accordingly.<p style="text-align: center;"><a href="img/opencpn.jpg" target="img"><img src="img/opencpn.jpg" title="Click to enlarge" width="701" height="558"></a><br><i>True Wind, available in OpenCPN.</i></p><p style="text-align: center;"><a href="img/opencpn.2.jpg" target="img"><img src="img/opencpn.2.jpg" title="Click to enlarge" width="701" height="558"></a><br><i>OpenCPN 3.3.2316 MDA support for barometric pressure</i></p>Following the exact same pattern, you can insert the current speed and direction (String VDR). See the <code>olivsoftdesktopuserexits.sample.TrueWindSentenceInsertion</code> and <code>olivsoftdesktopuserexits.LongTimeCurrentCalculator</code> user exits to see how.</p><p><div onclick="displayTWSection();" title="Click here for details" style="padding: 5px; background:#ffffcc; border-radius:5px; border:1px solid #CCC; margin-top:10px; margin-left: 10px; margin-right: 10px;"><dl><dt><h5>&nbsp;Hint: What is True Wind and Current calculation?</h5></dt><dd><div id="true-wind" style="display: none;">The calculations of the True Wind and the Current are not very complicated, but they rely on several parameters. Determining the values of those parameters is absolutely <b><i>crucial</i></b>.<br><p style="text-align: center;"><img src="img/tw.png" width="634" height="424" alt="All the calculation elements" title="All the calculation elements"></p>The wind measured by the instruments is the <b>Apparent Wind</b>. This is the vectorial combination of the <b>True Wind</b> with the <b>Boat Speed and Course <i>over the ground</i></b>. This is the wind you feel when riding your bike in no wind. You feel wind even if there is none.<br>The <b>True Wind</b> can be calculated by triangulation, as seen above. The <b>Apparent Wind</b> is in blue, the <b>True Wind</b> is in black, and the pink vector is generated by the boat speed and heading <i>over the ground</i>. And this is where it can become tricky.<p style="text-align: center; align: center;"><table style="margin: auto;"><tr><td><img src="img/headings.png" width="397" height="400" alt="All the headings" title="All the headings"></td><td><img src="img/all.vectors.png" width="450" height="400" alt="All the calculation elements" title="All the calculation elements"></td></tr></table></p>You need the <b>True North</b> for any further computation, but what you have on board is a compass, showing you its <b>Compass' North</b>.<ul><li>The <b>True North</b> is the North of the charts</li> <li>Between the <b>True North</b> and the <b>Magnetic North</b> is the <b>Magnetic Declination (D)</b>, that varies with the date and the location</li> <li>Between the <b>Magnetic North</b> and the <b>Compass' North</b> is the <b>Compass' deviation (d)</b>, generated by the magnetic masses on board. It depends on the boat, and on its heading. You have on board a <i>deviation curve</i> that tells you the value of the deviation based on your heading.</li> <li>The algebric sum of the deviation and the Declination is called the <b>Variation</b>, noted <b>W</b>.</li> <li>Once you have the <b>True Heading</b>, you need to get the <b>Course Made Good</b>, by adding (or substracting) the <b>leeway</b> to it. The <b>leeway</b> is generated by the wind and waves, it has to be <i>estimated</i> by the navigator. The leeway is an angle.</li> <li>And between the <b>Course Made Good</b> and the <b>Course Over Ground</b>, is the current. As seen above, the current is a vector (not an angle).</li></ul>It is <i>not</i> possible to come up with an accurate computation of the current <i>without</i> the right estimation of the leeway.<br>In theory, the current could be calculated by triangulation - like the true wind from the apparent Wind.<br>In practice, it is much more accurate over time.<p style="text-align: center;"><img src="img/current.png" width="634" height="424" alt="Current over Time" title="Current over Time"></p>On the figure above:<ul><li>The left pane shows the triangulation</li> <li>The middle pane compares the Course Over Ground (from the GPS) and the estimated position based on all the parameters above <b>on a 1 minute period</b></li> <li>The right pane compares the Course Over Ground (from the GPS) and the estimated position based on all the parameters above <b>on a 10 minute period</b></li></ul>The experience does prove that the estimation on a several minutes period is much more accurate than the triangulation, mostly because of the movements of the boat, that impact the data read by the wind vane.<br><br>Honestly, <b>no</b> embarqued electronic station can come up with a right evaluation of<ul><li>The compass' deviation</li> <li>The leeway</li> <li>The current</li></ul>Being able to <i>compute</i> those data, and then <i>inject</i> them in the NMEA stream is a real asset. The Raspberry PI is perfectly equiped to take care of all that, and for a ridiculous energy comsumption.</div></dd></dl></div></p><div onclick="displayTWCalcSection();" title="Click here for details" style="padding: 5px; background:#ffffcc; border-radius:5px; border:1px solid #CCC; margin-top:10px; margin-left: 10px; margin-right: 10px;"><dl><dt><h5>&nbsp;Hint: What to calculate True Wind with?</h5></dt><dd><div id="true-wind-calc" style="display: none;">This would seem obvious to some, but absurd to others. That's why we have this small explanation here.<br><br>For years, it was admitted that the true wind should be calculated with the <b>C</b>ourse <b>M</b>ade <b>G</b>ood (CMG), the <b>A</b>pparent <b>W</b>ind <b>A</b>ngle (AWA), <b>A</b>pparent <b>W</b>ind <b>S</b>peed (AWS), and <b>B</b>oat <b>SP</b>eed (BSP). The AWS and AWA are returned by the wind vane and anemometer, BSP by the speedometer (BSP is also called <b>S</b>peed <b>T</b>hrough <b>W</b>ater (STW)). The elaboration of the CMG is not trivial, as explained just above.<br>The reason for that is probably because this is all we had at that time.<br><br><i>But picture that (and draw a sketch if needed):</i><br>You are "sailing" in <b>no</b> wind <i>at all</i> (like in the San Francisco Bay in winter), and a 5 knot current is taking you out of the Bay (or inside, or wherever).<br>BSP is zero, <b>T</b>rue <b>W</b>ind <b>S</b>peed (TWS) is zero too, and in this case, AWS would be the speed of the current (5 knots), the AWA will depend on (but be equivalent to) the direction the current is taking you to.<br>If you calculate the TWS based on BSP, CMG, AWA and AWS, you will find a TWS equal to AWS - which is wrong because there is <i><u>no</u> wind</i>, and a wrong TWA (and <b>T</b>rue <b>W</b>ind <b>D</b>irection (TWD) as well, no wind has no direction).<br><b><i>But</i></b>, if you replace BSP with <b>S</b>peed <b>O</b>ver <b>G</b>round (SOG), and CMG with <b>C</b>ourse <b>O</b>ver <b>G</b>round (COG), you are back in business; COG is the current direction, SOG is the current speed.<br>Think about it.<br><br>This obviously requires the knowledge of SOG &amp; COG, returned by a GPS.<br><br>When the boat is moving, that eventually means that an accurate TWA and TWS (and TWD) is elaborated by a accurate knowledge of<ul><li>COG</li> <li>SOG</li> <li>AWA</li> <li>AWS</li> <li>CMG</li></ul>In short: this is not trivial. At all, by far, mostly because of CMG (see above for details).<br>You will notice that in the Console, you have the possibility to compute the True Wind from (BSP, CMG), or from (SOG, COG). This way you can have an idea of the difference it generates...</div></dd></dl></div><p><h3>Other Boards?</h3>We've been talking about the Raspberry PI here. Why not other boards?<br>There are indeed many such boards already available, and new ones show up almost every day.<br>The criteria to choose the right board for your project could be - among others:<ul><li>The price</li> <li>The energy consumption</li> <li>The power of the board (CPU, memory)</li> <li>Network connectivity</li> <li>Openness and Extensibility</li> <li>... and all this kind of things.</li></ul>As of now (2015), a Raspberry PI B (and B+) costs less than $40. A Raspberry PI A (and A+) comes for less than $30.<br>An Arduino Uno is less than $20 (and this is a great board, probably the one that started all this), but to get the network, you need an extra shield that you will get for another $20. And the Arduino Uno has 32Kb of memory (yes, <b>Kb</b>, this is not a typo).<br>The BeagleBone is more powerfull than the Raspberry PI, but also more expensive.<br>The Raspberry PI comes with Linux and Java (both free and OpenSource). It has the GPIO Header we need for extensibility.<br>It does indeed seem to be the right choice for this project, mostly because of its memory, CPU, and connectivity capabilities. Even the Raspberry PI A+ (which I just tested) works just great. It comes with 256Mb of RAM, it has <i>no</i> Ethernet port, and just <i>one</i> USB port. The energy consumption is even lower than on the Raspberry PI B. And it is even smaller.<br><dl><dt>About the CPU and memory</dt><dd>It is interesting to remind the youngests of us that 25 years back, I was working with a desktop that had 25 Mb of RAM (yes, about 10 times less than the Raspberry PI Model A). And this was a <i>huge</i> machine. At that time, programming skills included saving (and reusing) memory. That is a skill to keep alive in this area.</dd></dl><br>The B+ and A+ models use a micro-SD Card, very small in size (the actual challenge is not to lose it), not in capacity.<br>Here is a screenshot showing <code>top</code> running on the Raspberry PI A+, with all the features above running, including the WebSocket server (nodejs).<p style="text-align: center;"><a href="img/top.png" target="top"><img src="img/top.png" width="337" height="212" alt="Click to enlarge" title="Click to enlarge"></a><br><i>Top at work</i></p>My favorite configuration today (Dec-2014) would definitely include<ul><li>A Raspberry PI A+</li> <li>A USB Hub (for NMEA input, wireless dongle, wireless keyboard)</li> <li>A small breadboard on the side, for extra I<small><sup>2</sup></small>C sensors</li></ul>This being said, <i>any</i> Raspberry PI currently available would fit, as well as Banana PI, BeagleBone, Olimex, etc. I believe that the Raspberry PI A+ is the one drawing the smallest amount of energy, among all the boards running Linux &amp; Java (correct me if I'm wrong). Any board running Java (on Linux or not), and able to connect to a network will do the job.<br>One of my goals here was to save as much energy as possible.</p><p><table width="98%"><tr><td><h2><a name="02-2"><h2>Summary</h2></a></h2></td><td align="right"><a href="#"><small>Top</small></a></td></tr></table><ul><li><b>By default</b>, the NMEA Serial port is connected on the laptop.<ul><li>Whatever program that needs to read the Serial port will have to wait for the port to be available.</li> <li>Whatever data is not emited by the NMEA station is just not available</li></ul></li><li><b>With the Raspberry PI in the picture</b>, the NMEA Serial port in read by the Raspberry PI. Other devices will use another protocol to reach the data (TCP, UDP, etc).<ul><li><i>Several</i> programs, running on several devices, can use the NMEA data <i>simultaneously</i></li> <li>Sensors can <i>enrich</i> the NMEA Stream (read by the devices and programs mentioned above)</li> <li>Extra data can be <i>computed</i>, and injected into the NMEA Stream</li></ul></li></ul></p><p><table width="98%"><tr><td><h2><a name="03"><h2>Resources</h2></a></h2></td><td align="right"><a href="#"><small>Top</small></a></td></tr></table><ul><li><a href="http://raspberrypi.org" target="RPi">Raspberry PI</a></li> <li><a href="http://opencpn.org" target="OpenCPN">OpenCPN</a></li> <li><a href="http://sailmail.com" target="Airmail">Airmail</a></li> <li><a href="http://nodejs.org" target="node">Node.JS</a></li> <li><a href="https://code.google.com/p/javanmeaparser/" target="JNP">Java NMEA Parser</a></li> <li><a href="https://code.google.com/p/fullnmeaconsole/" target="JNC">Java Navigation Console</a></li> <li><a href="https://code.google.com/p/navigation-desktop-user-exits/" target="UE">User-Exits for the Navigation Console</a></li> <li><a href="https://code.google.com/p/raspberry-pi4j-samples/" target="JRPi">Java Projects Samples for the Raspberry PI</a></li> <li><a href="http://www.lediouris.net/RaspberryPI/ADC/monitor-12v.html" target="12V">The battery monitoring trinket</a></li></ul>The pdf documentation of the NMEA Console (included in the Navigation Desktop) can be found <a href="https://drive.google.com/?authuser=0#folders/0B1OXF1qWHj9mZFZxUkV1cUZFblk" target="GD">here</a>.</p></p><p><table width="98%"><tr><td><h2><a name="04"><h2>Some last comments</h2></a></h2></td><td align="right"><a href="#"><small>Top</small></a></td></tr></table><p>Originally, the software (the NMEA Console) was written to run on a laptop.<br>Putting the Raspberry PI in the picture substancially changed the paradigm, the architecture clearly became hub-and-spoke oriented.<br>The cache architecture was also quite impacted. An easy way around the problems raised by this hub-and-spoke architecture is to generate new NMEA Strings <i>from</i> the Raspberry PI, and inject them into the NMEA Stream. This is the case for the Atmospheric Pressure, the True Wind computation, the Current computation (with time buffer), and the list is not closed.<br>For the data that do not have an NMEA equivalent (like the battery load), I just came up with my own ones. All it requires is to have the software reading them to be aware of those (like the character console).</p><p>All the software used here is Open Source software, and as such, is free.<br>The hardware follows the same path (beside the boat itself, of course, and the NMEA electronics), the price for a Raspberry PI is ridiculous, the extra sensors, boards, small keyboards, small screens, and various components you would need to do the same will fit more than once in a $100 budget.<br>It is interesting though, to notice that this architecture is the <i>exact same one</i> that was used during the recent 34th America's Cup by those multi-million$ fantastic cats - including the glorious winner.<br>Well, now you can get to the data, you have to analyze them. And the next America's Cup is all yours.</p>Enjoy!</p><hr><address>Oliv fecit, AD 2014.</address></body></html><!--//--><script language="JavaScript" src="http://l.yimg.com/d/lib/smb/js/hosting/cp/js_source/whv2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1421846030" alt="setstats" border="0" width="1" height="1"></noscript><script type="text/javascript">(function(d,w){var x=d.getElementsByTagName('SCRIPT')[0];var f=function(){var s=d.createElement('SCRIPT');s.type='text/javascript';s.async=true;s.src="//np.lexity.com/embed/YW/42a76f6aa09fa2ab64f6bfe0f0472748?id=9537312fd9d7";x.parentNode.insertBefore(s,x);};w.attachEvent?w.attachEvent('onload',f):w.addEventListener('load',f,false);}(document,window));</script>