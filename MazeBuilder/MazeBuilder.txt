My education in programming truly began when I traded my hard-earned money for a copy of “The Creative Atari”.  Sure, I knew my way around the BASIC programming language, but so did most kids back in the mid-eighties.  Similar to most kids back then, I was far more interested in typing in the games than I was in actually learning something.  Luckily for me, this new tome was not just a collection of few BASIC programs. Instead, each programmer had been thoughtful enough to include a write up with his contribution that not only explained the nuts and bolts of the code, but took us deep into the development process.  These articles were written in such a way that it stuck with me for the next thirty years.

Maze Master

“Maze Master” was a fun little offering by Fred Brunyate, which would give the player a new maze each time it was run.  Having a limited supply of quarters had already prodded me to attempt to program my own games.  A program that generated a random maze with only one path from start to finish would give me lot to work with.  Even better, was that Fred’s explanation gave me everything I needed to adapt this concept to an entertaining dungeon-crawler game.  Years later, while learning C, I wrote a version of the maze builder in C.  Now learning Python, I repeated the process and produced another maze builder.  Clearly, Fred had provided me with a fun little exercise to encourage me while learning new programming languages.  This article contains the Python version, such that that others may benefit.

The ideas Fred provided are pretty straight-forward.  Start at any point within a two-dimensional array. Mark the block you are standing in, so you cannot move back into it.  Now look at the four squares around you, and see which ones you can move into.  Once you have made that list of potential moves, pick one at random.  Repeat that process until there is nowhere left for you to move.  Once you have boxed yourself into a dead end, simply choose a new position in the array that you have already been in and continue moving.  Choosing a location, in which you have already been, insures that all the maze branches are connected together.  Repeat this process until all the squares in the array have been tagged.

In Python

Python is a great choice for this exercise. If you look at the program listing, you can see that I have divided it up into three main parts:  build_maze, print_maze, and main. Starting with main, we can see that the first thing that happens is that the program asks the user how big the maze should be.  With that information, the programme then initialises the two-dimensional array of the requested size to all ‘0’s.  

The main loop in the programme first checks to see if there are any cells left in the array that have not been moved into.  If there are still some available, it makes a list of possible moves (left, right, up, and down) based on what is around the cell it is in.  The program then makes a random choice based on the list it has compiled.  Now things begin to get a little confusing.  The same array that keeps tracks of whether or not a cell has been moved into, also keeps track of how the walls on each cell are set up. This program will only concern itself with the lower wall and the right wall of each cell, with the upper wall being handled by the cell above and the left wall being defined by the cell to the left.  A value of 4 means that both the lower and the right-hand wall of a cell are in place.  A value of 1, means that both the lower wall and right-hand wall are absent.  Values of 2 and 3 correspond to only the right-hand wall or lower wall respectively.  Based on which random direction the program has decided move in, it will update both the cell it is currently in and the cell it moves into.

The last part of the program is print_asci_maze.  All this does is print out the completed maze, based on the array it is fed.  Back in my Atari days, I had solid block graphics that made excellent walls and intersections.  As I am still feeling out Python’s capabilities, I have decided to just use the characters +, -, and | for now. 

Hopefully you have enjoyed this exercise as much as I have.  More importantly, I hope that any budding programmers will come away with an understanding of the application of a simple concept that can be applied to help you learn new languages.  Keep on coding!
where S is the start and F is the finish.  Every time the program is run, the maze is different!
